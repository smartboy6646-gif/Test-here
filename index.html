<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rock Paper Scissors Auto-Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f0f0f0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>

<script>
class MainScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainScene' });
    }

    preload() {
        // No external assets needed, using pure Text objects
    }

    create() {
        // --- Configuration ---
        this.entityCount = 60; // Total entities
        this.speedBase = 150;  // Base velocity
        this.types = ['rock', 'paper', 'scissors'];
        this.emojis = { rock: 'ü™®', paper: 'üìÑ', scissors: '‚úÇÔ∏è' };
        this.colors = { rock: '#555555', paper: '#aaaaaa', scissors: '#e74c3c' };
        
        // --- State ---
        this.entities = this.physics.add.group();
        this.simulationRunning = true;
        this.timeScaleValue = 1;

        // --- Create Entities ---
        for (let i = 0; i < this.entityCount; i++) {
            this.spawnEntity();
        }

        // --- Collisions ---
        this.physics.add.collider(this.entities, this.entities, this.handleCollision, null, this);

        // --- UI Layer ---
        this.createUI();

        // --- Controls ---
        this.createControls();
    }

    spawnEntity() {
        const x = Phaser.Math.Between(50, this.scale.width - 50);
        const y = Phaser.Math.Between(100, this.scale.height - 50);
        const type = Phaser.Utils.Array.GetRandom(this.types);
        
        const entity = this.add.text(x, y, this.emojis[type], {
            fontSize: '32px'
        });

        // Setup Physics
        this.physics.add.existing(entity);
        entity.body.setCollideWorldBounds(true);
        entity.body.setBounce(1, 1);
        
        // Circular collider approximates the emoji shape better
        entity.body.setCircle(16, 0, 0); 
        
        // Random Velocity
        const vx = Phaser.Math.Between(-this.speedBase, this.speedBase);
        const vy = Phaser.Math.Between(-this.speedBase, this.speedBase);
        entity.body.setVelocity(vx || 100, vy || 100); // Ensure not zero

        // Store type data
        entity.setData('type', type);
        
        this.entities.add(entity);
    }

    handleCollision(obj1, obj2) {
        if (!this.simulationRunning) return;

        const type1 = obj1.getData('type');
        const type2 = obj2.getData('type');

        // If same type, just physics bounce (handled by collider), no logic needed
        if (type1 === type2) return;

        // Rock(0) > Scissors(2)
        // Scissors(2) > Paper(1)
        // Paper(1) > Rock(0)

        let winner = null;
        let loser = null;

        // Logic
        if (type1 === 'rock' && type2 === 'scissors') { winner = obj1; loser = obj2; }
        else if (type1 === 'scissors' && type2 === 'paper') { winner = obj1; loser = obj2; }
        else if (type1 === 'paper' && type2 === 'rock') { winner = obj1; loser = obj2; }
        else if (type2 === 'rock' && type1 === 'scissors') { winner = obj2; loser = obj1; }
        else if (type2 === 'scissors' && type1 === 'paper') { winner = obj2; loser = obj1; }
        else if (type2 === 'paper' && type1 === 'rock') { winner = obj2; loser = obj1; }

        if (winner && loser) {
            this.convertEntity(loser, winner.getData('type'));
        }
    }

    convertEntity(entity, newType) {
        // Visual feedback
        entity.setText(this.emojis[newType]);
        entity.setData('type', newType);

        // Pop animation
        this.tweens.add({
            targets: entity,
            scaleX: 1.5,
            scaleY: 1.5,
            duration: 100,
            yoyo: true,
            ease: 'Sine.easeInOut'
        });
    }

    createUI() {
        const style = { font: 'bold 20px Arial', fill: '#333' };
        
        this.rockText = this.add.text(20, 20, '', style);
        this.paperText = this.add.text(120, 20, '', style);
        this.scissorsText = this.add.text(240, 20, '', style);

        // Win Text (Hidden initially)
        this.winText = this.add.text(this.scale.width / 2, this.scale.height / 2, '', {
            font: 'bold 48px Arial',
            fill: '#000',
            backgroundColor: '#ffffffaa',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setVisible(false).setDepth(100);
    }

    createControls() {
        // Speed Button
        const btnStyle = { font: '16px Arial', fill: '#fff', backgroundColor: '#333', padding: { x: 10, y: 5 } };
        
        this.speedBtn = this.add.text(this.scale.width - 100, 20, 'Speed: 1x', btnStyle)
            .setInteractive({ useHandCursor: true })
            .on('pointerdown', () => this.toggleSpeed());

        // Restart Button
        this.restartBtn = this.add.text(this.scale.width - 180, 20, 'Restart', btnStyle)
            .setInteractive({ useHandCursor: true })
            .on('pointerdown', () => this.scene.restart());
    }

    toggleSpeed() {
        if (this.timeScaleValue === 1) {
            this.timeScaleValue = 2;
        } else if (this.timeScaleValue === 2) {
            this.timeScaleValue = 4;
        } else {
            this.timeScaleValue = 1;
        }
        
        this.physics.world.timeScale = 1 / this.timeScaleValue; // Physics timeScale is inverse (smaller = faster)
        this.speedBtn.setText(`Speed: ${this.timeScaleValue}x`);
    }

    update() {
        if (!this.simulationRunning) return;

        // Count entities
        let r = 0, p = 0, s = 0;
        
        this.entities.getChildren().forEach(e => {
            const type = e.getData('type');
            if (type === 'rock') r++;
            if (type === 'paper') p++;
            if (type === 'scissors') s++;
            
            // Minimal random movement jitter for "organic" feel
            if (Phaser.Math.Between(0, 100) > 98) {
                e.body.velocity.rotate(Phaser.Math.DegToRad(Phaser.Math.Between(-15, 15)));
            }
        });

        // Update UI
        this.rockText.setText(`${this.emojis.rock} ${r}`);
        this.paperText.setText(`${this.emojis.paper} ${p}`);
        this.scissorsText.setText(`${this.emojis.scissors} ${s}`);

        // Check Win Condition
        this.checkWin(r, p, s);
    }

    checkWin(r, p, s) {
        const total = r + p + s;
        let winner = '';

        if (r === total) winner = "ROCK WINS!";
        else if (p === total) winner = "PAPER WINS!";
        else if (s === total) winner = "SCISSORS WINS!";

        if (winner !== '') {
            this.simulationRunning = false;
            this.physics.pause();
            this.winText.setText(winner).setVisible(true);
            
            // Celebration Tween
            this.tweens.add({
                targets: this.winText,
                scale: 1.2,
                duration: 500,
                yoyo: true,
                repeat: -1
            });
        }
    }
}

const config = {
    type: Phaser.AUTO,
    scale: {
        mode: Phaser.Scale.RESIZE,
        parent: document.body,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: window.innerWidth,
        height: window.innerHeight
    },
    backgroundColor: '#f8f9fa',
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: false
        }
    },
    scene: MainScene
};

const game = new Phaser.Game(config);

// Handle window resize dynamically
window.addEventListener('resize', () => {
    game.scale.resize(window.innerWidth, window.innerHeight);
});

</script>

</body>
</html>
